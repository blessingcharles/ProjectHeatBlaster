
## INTRODUCTION :

  Heat Blaster is a reverse proxy which can act as a load balancer and web application firewall , which is powered by the ML model to detect malicious http requests and prevent it by reaching the backend servers. The web application firewall is developed in a layered architecture , each layer has a ML model which has its own functionality to analyse the http request and forward it to the next layer. As the WAF follows layered architecture so we can enable or disable any layer according to our wish. The proxy server also logs both normal and malicious request information in log files for future analysis. The load balancer in the reverse proxy is implemented in round robin fashion and it also keeps a log file for uptime for each backend server.

### BLOCK DIAGRAM
![block diagram](https://github.com/blessingcharles/ProjectHeatBlaster/blob/Main/pngs/block%20diagram.png?raw=true)

### ARCHITECTURE DIAGRAM
![architecture diagram](https://raw.githubusercontent.com/blessingcharles/ProjectHeatBlaster/Main/pngs/b.png)

### Complete Flow

The http request send by the user is first processed by each layer in

the web application firewall.All these modelsare highly configurable like
which algorithmtouse,or a layer can be completely disabled as per wish
of the developer.

The Two Layers of WAF :
1) User Agent Classifier
2) Payloads Detector

**User Agent Classifier** :

The first ml model is used to analyze the user agent of the request​ and classify it , if the request is generated by a normal browser it​ contains a user agent which follows from standardization , if it is​ generated by various security tools(sqlmap) or automated bots we can​ capture the request and block it . So the ml model can classify​ between if the user agent is malicious or not . Since user agents can​ be forged by hackers , it is not completely fool proof but it can protect​ from script kiddies and roast the request in the first layer itself .

### Payload Predictor :

The second ML model is used to analyse the inputs given by the​ users from http parameters , query and http POST request body ,​classify them if it is a normal input given by the user or if it is a​ malicious payload from the hackers . The ML model is trained with​ malicious payload vectors for xss , sql , nosql , ssrf , xxe attacks . So​ the ML model is able to classify normal requests from malicious​ requests . The malicious requests are roasted in this layer and only​ normal requests are served to the backend

**Overall Algorithm**

Get http data as input to reverse proxy :

```
Bog = CountVectorizer(user-agent);
If user_agent_model(Bog) is malicious:
Block_request();
Else :
Payload = feature_extractor(user_input);
If payload_model(Payload) is malicious:
Block_request();
Else:
Route_request()
Load_Balance(backend_servers);
```

### ML models Algorithms Available

```
The developer can configure which dumped model should be used in
```
production environment by changing in the environment variable of the reverse

proxy application. The classification algorithms supported are

1) Support Vector Classifier

2) Logistic Regression

3) Decision Tree

4) Multinomial Naïve Bayes

5) Random Forest

## MODULES OVERVIEW

### Tree View of modules

#### 

```
├── blasterDB
├── blasterModels
│ ├── payloads_models
│ └── user_agents_models
├── env
├── heatblaster
│ ├── build


│ ├── data_collection
│ ├── datasets
│ ├──ml_notebooks
├── README.md
├── requirements.txt
├── ReverseProxy
│ ├── load_balancer
│ ├── mod_request_handlers
│ ├── mod_roaster
│ ├── templates
│ └── utils
├── run.py
```

**Reverse Proxy module** :


It’s the Core module which co-operates the load balancing , routing and the

web application firewall where the layers of ml model presents.

It further consists of sub modules

```
1) load_balancer : contains logic of how to load balance among the backend servers

2) mod_request_handlers : contains logic of how to route requests
3) mod_roaster : contains the layers of web application firewall
4) templates : html templates for the reverse proxy
5) utils : utility functions for all sub modules
```

HEAT BLASTERMODULE

```
It contains all the Machine Learning Model training functions and preprocessing

steps in jupyter notebook. From here only ml models are dumped using joblib library

, then they are loaded into reverse proxy according to environmental configurations

mentioned by the developer.
```
### BlasterDb :

```
It contains all the data needed for the reverse proxy , which actually acts
similar to database to all the modules.
```

### ENV :

```
It contains all the environment variables for configuring the reverse proxy , the
configs are httpconfig , proxyconfig , mlconfig , serverconfig.
```

### Blaster Models :

```
It contains all the dumped ml model in two different sub directories of
1) payload models
2) user agents models
```

The different Ml models available for each layer:

User Agent Classifier(Layer 1) :

```
i) Count Vectorizer models
```
Payload Predictor

```
i) Custom Feature extraction (like special characters etc)
ii) Count Vectorizer models
```
### LIST OF MODELS


## Machine Learning in the Reverse Proxy

The heat blaster modules contains the jupyter notebooksof the
machine learning models where the preprocessing steps and training of the
model occurs. The trained model are then dumped into blasterModels directory ,
from where they can be loaded into the reverse proxy , which acts to filter out
malicious requests.


## Preprocessing Steps for User agent Model:

UserAgents Model Preprocessing Steps

The useragent is extracted from the http headersof the http request
which is then converted into bag of words using countvectorizer.

CountVectorizer tokenizes ( tokenization means dividing the sentences
in words) the text along with performing very basic preprocessing. It


removes the punctuation marks and converts all the words to lowercase.
The vocabulary of known words is formed which is also used for encoding
unseen text later. The vocabulary of known words is formed which is also
used for encoding unseen text later.

**CountVectorizer** is a great tool provided by the scikit-learnlibrary in
Python. It is used to transform a given text into a vector on the basis of the
frequency (count) of each word that occurs in the entire text. This is helpful
when we have multiple such texts, and we wish to convert each word in
each text into vectors

### Preprocessing Steps for Payload model:

The normal payloads inputs are collected from google trends
dataset from kaggle and the malicious payloads are collected from different
payloads of xss , sql , ssrf , xxe attacks used by security researchers and
pentesters in the wild. There are two types of feature extraction is done in
the payload data , the first one is similar to the previous user agent model
ie. count vectorizer and the second one is getting the characters count
which are not normally found in normal user inputs.

The custom Features are

```
1.Length
2.Nonprintable_keywords
3.Special_chars
4.Punctuation_chars
5.Js_events
6.Html_tags
7.Sql_keywords
8.Percentage_count
9. spaces_count
```



The developer can configure any models from thesenlp
preprocessing and custom feature preprocessing models in the reverse
proxy , as all the 6 classification algorithms are trained in this two different
datasets which leads to 12 different models available for the developer to
choose.


### Training the models

As there are 18 models to train , 6 models for user agents , 6 count vectorizer models for
payloads and 6 custom feature payload models to train .The algorithm are imported from
sklearn library and they are dumped using joblib library. The classification algorithms used in
the project are

1. Support vector classifier
2. Logistic Regression
3. K nearest neighbours
4. Decision Tree
5. Random Forest
6. Multinomial Naive Bayes

### Hyper Parameter Tuning

In machine learning, hyperparameter optimization or tuning is the problem of choosing a
set of optimal hyperparameters for a learning algorithm. A hyperparameter is a parameter
whose value is used to control the learning process. By contrast, the values of other parameters
(typically node weights) are learned.


Since it will takes lot of slides , the results can be seen in the project github
https://github.com/blessingcharles/ProjectHeatBlaster

### Model Evaluation Metrics 
##### all evaluation metrics can be found in heatblaster directory (jupyter notebooks) 

```
  More info contact : https://twitter.com/th3h04x
```

## REFERENCE PAPERS

1) Web Application Attacks Detection Using Machine Learning Techniques
https://ieeexplore.ieee.org/document/8614199

2) Development of a hybrid web application firewall to prevent web based
attacks
https://ieeexplore.ieee.org/document/7035910


